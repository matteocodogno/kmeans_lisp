;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;                           MEMBRI GRUPPO PROGETTO                             ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;                                                                              ;
;    NOME/COG:  Matteo Codogno       (730620)                                  ;
;                                                                              ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;                               TESTO PROGETTO                                 ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;                                                                              ;
; Uno degli algoritmi principali (e piu` semplici) utilizzati nell’analisi     ;
; statistica dei dati1 `e noto come l’algoritmo di clustering delle k-medie.   ;
; L’obiettivo di un algoritmo di clustering `e, dato un insieme di n oggetti   ;
; (o osservazioni), partizionarli in k sottoinsiemi (o categorie non           ;
; predefinite) che raggruppino oggetti che condividono delle propriet. Ad      ;
; esempio un algoritmo di clustering applicato a delle immagini telerilevate   ;
; potrebbe partizionare le immagini sulla base della tipologia di scena        ;
; rappresentata, quale centri abitati, boschi, superfici acquee, ecc. In       ;
; particolare, l’algoritmo di clustering delle k-medie `e di partizionare n    ;
; osservazioni in k clusters (gruppi), dove ogni osservazione appartiene al    ;
; gruppo in cui cade la media piu` “vicina”. La “media” (detta centroide)      ;
; serve come “prototipo” del gruppo. Il centroide che rappresenta una          ;
; categoria viene in questo caso calcolato come la media degli oggetti del     ;
; gruppo e ne costituisce il prototipo.                                        ;
; In generale il problema `e NP-hard, ma la variante “euristica” di Lloyd      ;
; dell’algoritmo k-medie `e una soluzione abbastanza buona ed efficace. Una    ;
; limitazione dell’algoritmo k-medie `e che il parametro k deve essere         ;
; specificato dall’utente in anticipo.                                         ;
;                                                                              ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;                                                                              ;
; Il progetto KM si compone delle seguente sezioni:                            ;
;   1. funzioni manipolazione lista                                            ;
;   2. funzioni manipolazione vettori                                          ;
;   3. algoritmo kmeans                                                        ;
;                                                                              ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;                            MANIPOLAZIONE LISTA                               ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;                                                                              ;
; - ldiv/2        -> divide tutti gli elementi di una lista per una COSTANTE   ;
; - lexp/2        -> calcola l'esponenziale di ogni elemento della lista       ;
; - set-nth/3     -> cambia l'n-esimo elemento di una lista                    ;
;                                                                              ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;                           MANIPOLAZIONE VETTORI                              ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;                                                                              ;
; - innerprod/2   -> esegue la innerprod/3 ed esegue la lsum/2 sul risultato   ;
; - norm/1        -> calcola la norma di un vettore                            ;
; - vsum/2        -> somma tra vettori                                         ;
; - vsub/2        -> differenza tra vettori                                    ;
; - distance/2    -> calcola la distanza euclidea tra 2 vettori                ;
;                                                                              ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;                             ALGORITMO KMEANS                                 ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;                                                                              ;
; - forgy/2           -> implementazione del metodo forgy, sceglie in maniera  ;
;                        randomica 'N' centroidi tra le osservazioni           ;
; - distances/2       -> calcola le distanze tra un vettore e i diversi        ;
;                        centroidi                                             ;
; - choose_centroid/2 -> date le distanze tra un vettore e i centroidi,        ;
;                        sceglie il centroide più vicino                       ;
; - partition/2       -> accoda per ogni osservazione il centroide più vicino, ;
;                        in un'unica lista                                     ;
; - split_item/2      -> partendo dalla lista composta da osservazioni +       ;
;                        centroide, crea un cluster per ogni centroide con gli ;
;                        osservazioni a lui più vicine                         ;
; - spliting/2        -> crea una lista (cluster) con i vettori più vicini ad  ;
;                        un determinato centroide                              ;
; - centroid/1        -> calcolo dei centroidi per ciascun cluster             ;
; - compute_centroid/2-> calcolo del centroide di un cluster di vettori        ;
; - km/2              -> implementazione dell'algoritmo delle kmedie, data una ;
;                        lista di vettori e un numero di gruppi in cui         ;
;                        dividerli, raggruppa i vettori in 'N' gruppi divisi   ;
;                        per centroide                                         ;
; - compute_cluster/2 -> calcola i centroidi ottimali e divide le osservazioni ;
;                        su di essi, il metodo termina quando non vi sono più  ;
;                        ottimizzazioni da eseguire                            ;
;                                                                              ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
